# Project Generation Scripts

Basic instructions to run the project generation

### Vivado HLS project with hourglass configuration

* The master configuration file for hourglass project is generated by
		
      ./HourGlassConfig.py
    
  The default output file is *wires.input.hourglassExtended*.
  Each line in the output file contains a instance of a processing module as well as all its input and output memories. The input memories, the processing module, and the output memories are separated by ">":

       InMem1 InMem2 ... > ProcessModuleX > OutMem1 OutMem2 ...

* Create modules and wiring .dat files

      ./WiresLongVM.py wires.input.hourglassExtended

  This script parses the configuration file generated from the previous step and converts it to three output files: 
  *wires.dat*, *memorymodules.dat*, and *processingmodules.dat*.
  These three .dat files contain more or less the same information as the master config file but are reformated for more convenient access in emulation software and later steps.
  In *memorymodules.dat* and *processingmodules.dat*, each line contains a module instance name and its corresponding module type, following the format

     ModuleType: ModuleInstance

  (*FIXME*: for memorymodules.dat, there is a third column (e.g. "[36]") that is supposed to indicate the data width of the memory. This number is hardcoded and is likely out of date. It is not used in the later steps for generating top level project, but it may be less confusing if we either remove it or update the numbers or link it to the corresponding HLS memory header files.)
  
* Generate the top function for Vivado HLS

  (Currently CANNOT generate a full project since some processing steps are under construction)

      1) Checkout L1Trk HLS code (https://github.com/cms-tracklet/firmware-hls) into a new directory
      2) Ensure ROOT is in your PATH.
      3) ./generator_vhls.py <L1Trk HLS firmware directory>
      
  Optional arguments include:
  
      -h, --help          For help
  
      -f, --topfunc       Top function name
      -n, --projname      Project name
      -p, --procconfig    Name of the processing module configuration .dat file
      -m, --memconfig     Name of the memory module configuration .dat file
      -w, --wireconfig    Name of the wiring configuration .dat file
      --memprint_dir      Directory to search for memory printouts produced by the emulation
      --emData_dir        Directory into which the memory printout files are copied for the HLS project
      
      For generating a partial project:
      -r, --region        Detector region of the generated project.
      		              Choose from A(all), L(barrel), D(disk).
      --uut               Specify a unit under test, e.g. TC_L1L2E
      -u, --nupstream     The number of processing steps to be generated upstream of the UUT 
      -d, --ndownstream   The number of processing steps to be generated downstream of the UUT

  This script parses the three .dat files from the previous step and instantiates a TrackletGraph object (defined in TrackletGraph.py).
  The TrackletGraph object is a representation of the project configuration, containing all processing and memory objects as well as their inter-connections.

  The other part of this script takes the TrakletGraph object as inputs and writes out relevant files for the top level project.
  In order to generate correct and up-to-date functions for relevant processing steps, the script looks for and parses the function definitions in the corresponding header files in L1Trk HLS repo (https://github.com/cms-tracklet/firmware-hls/TrackletAlgorithm/).
  The final product of this script includes source and header files for the HLS top function, a test bench file, and a tcl script to generate the Vivado HLS project. A diagram presenting the generated project is also produced.
  In addition, the script tries to select and copy necessary memory printout files, if available, from the emulation to be used in the test bench of the Vivado HLS project.

-----------------------------------------------------------------

### Tracklet LongVM

The master configuration file for long VM project is wires.input.longVM_sector

* Generate reduced LongVM project configuration if needed:

      ./SubProject_longVM.py -r <region> -s <seedings>

      ./SubProject_longVM.py -h  for help

   It by default reads the master config file 'wires.input.longVM_sector' and generates a smaller scale project configuration 'wires.reduced', based on the user specified detector region (via option -r) and seeding pairs (via option -s).
   Choices for argument <region> are: 'A' (entire tracker), 'L' (barrel only), 'D' (disk only), 'H' (hybrid region).
   Choices for argument <seedings> are: 'L1L2', 'L3L4', 'L5L6', 'D1D2', 'D3D4', 'D1L1', 'D1L2', as well as any combinations of them. Note that in case the specified detector region is not entire detector, only seedings feasible in that region are allowed.

* Create connections for LongVM project:

       ./WiresLongVM.py <wires>

   Its input file <wires> could be either wires.input.longVM_sector for a full project or wires.reduced generated from previous step for a smaller scale project.
   This script will produce three output files: wires.dat, memorymodules.dat and processingmodules.dat. They could be used either as configuration files in emulation or in the next step to generate top level processing verilog modules for firmware.

* To generate verilog top level module:
   
       ./generator_longVM.py

       ./generator_longVM.py -h  for help

   It reads in wires.dat, memorymodules.dat and processingmodules.dat by default, and generates a verilog module by default named Tracklet_processing.v
   Copy Tracklet_processing.v to firmware/TrackletProject/SourceCode/ in order to implement it in firmware project.

-----------------------------------------------------------------

### Tracklet 1.0

* Reduce the project if needed:

      python SubProject.py D3 (or D3D4, D5D6, D3D4D5D6, etc.)

   This will generate an output file: wires.reduced   


* Create the connections:

      python Wires.py wires.input.D3

(or some other input file like wires.input.fullsector or wires.reduced generated from the previous step)


* To generate verilog top level code:

      python generator.py D3(or D3D4, D5, etc.)

-----------------------------------------------------------------

### To plot:

* Prepare files for graph generation:

      ./Graph.py

* Make graph in root:

      root -l
      root[0] .L DrawTrackletProject.C++
      root[1] DrawTrackletProject()

* You can also generate the 'zoomed in' views of all the processing modules
after running the Wires.py script by doing

      ./generatesubgraphs
